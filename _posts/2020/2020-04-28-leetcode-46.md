---
layout: post
title: leetcode - [46] Permutations
category: algorithm
tags: [algorithm]
excerpt: Permutations
---

## 题目描述  

> Given a collection of distinct integers, return all possible permutations.  

统计一个非重复数组的排列情况。  


举个例子：  

``` java
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```


## Update at 2020_0618  

类似题目：  

[[78] Subsets](http://yaoyichen.cn/algorithm/2020/02/21/leetcode-78.html){:target="_blank"}
[[90] Subsets II](http://yaoyichen.cn/algorithm/2020/06/18/leetcode-90.html){:target="_blank"}

那么这道题目与`SubSets`的区别是什么呢？  

首先，`Subsets`一旦进入递归方法，则先将子列表加入结果列表中。  

但是，`Permutations`不能这样做，需要判断条件。  

只有当`child`子列表中元素数量等于原始数组长度时，才添加。  

第二，递归方法中的遍历方式不同，在`SubSets`中需要一个记录当前索引的变量`cur`。  

但是，`Permutations`不需要，因为它需要回过头来添加之前的元素。  

那么它是如何做到排列的呢？  

其实就是不断地从头到尾遍历原始数组，如果数组中包含当前值，则跳过。  

来看下实现：  

``` java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        
        List<List<Integer>> ans = new LinkedList<>();
        bt(nums, ans, new LinkedList<>());
        return ans;
    }
    
    private void bt(int[] nums, List<List<Integer>> ans, LinkedList<Integer> child){
        
        int len = nums.length;
        if (child.size() == len){
            ans.add(new LinkedList<>(child));
        } else {
            for (int i = 0; i < len; i++){
                // Skip duplicates
                if (child.contains(nums[i])){
                    continue;
                }
                child.add(nums[i]);
                bt(nums, ans, child);
                child.removeLast();
            }
        }
    }
}
```

## 解法1


Thanks [@issac3](https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning)){:target="_blank"}  

这位大侠在讨论区同时发了好几道类题目的题解，我要花几天时间好好消化消化~~   


![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_46.png)  

``` java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    doPermute(list, nums, new ArrayList<>());
    return list;
}

public void doPermute(List<List<Integer>> list, int[] nums, List<Integer> tmpList){
    if (nums.length == tmpList.size()){
        // Be careful
        list.add(new ArrayList(tmpList));
    } else {
        for (int i = 0; i < nums.length; i++){
            if (tmpList.contains(nums[i])) continue;
            tmpList.add(nums[i]);
            doPermute(list, nums, tmpList);
            tmpList.remove(tmpList.size() - 1);
        }
    }
}
```

`Amazing!`