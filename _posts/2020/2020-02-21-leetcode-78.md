---
layout: post
title: leetcode - [78] Subsets
category: algorithm
tags: [algorithm]
excerpt: Subsets
---

## 题目描述  

> Given a set of distinct integers, nums, return all possible subsets (the power set).  

给一个不重复的数组，计算出所有可能的子集。  

举个例子：  

``` java
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

说实话，想了很久，没想到合适的解法，后来参考讨论区，如下：  


## Update at 2020_0618  

此题应该使用回溯思想。  

先来看下示意图：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_78_key.png)  


首先，递归方法中我们需要用到哪些东西？  

`nums`原始数组、一个索引值`cur`、一个临时列表`child`和一个最终结果列表`ans`。  

然后，递归方法中需要做哪些事情？  

第一，需要将当前临时列表`child`加入`ans`中。  

第二，遍历`原始数组`，记住是从索引值`cur`开始，并做三件事情：  

- 添加当前元素。  
- 继续递归遍历，注意，索引值`cur`需要`+1`。  
- 删除当前元素。  


来看下实现：  

``` java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        
        List<List<Integer>> ans = new LinkedList<>();
        bt(nums, 0, new LinkedList<>(), ans);
        return ans;
    }
    
    private void bt(int[] nums, int cur, LinkedList<Integer> child, List<List<Integer>> ans){
        
        ans.add(new LinkedList<>(child));
        
        for (int i = cur; i < nums.length; i++){
            child.add(nums[i]);
            bt(nums, i + 1, child, ans);
            child.removeLast();
        }
    }
}
```


## 解法1  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/subset.png)  


``` java
public static List<List<Integer>> p78(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    res.add(new ArrayList<>());
    for (int n: nums){
        int size = res.size();
        for (int i = 0; i < size; i++){
            List<Integer> tmp = new ArrayList<>(res.get(i));
            tmp.add(n);
            res.add(tmp);
        }
    }
    return res;
}
```

特别是`res.get(i)`非常惊艳！  



## `Reference`  
- [3 Java solutions: bit, iterative, and recursive](https://leetcode.com/problems/subsets/discuss/299755/3-Java-solutions%3A-bit-iterative-and-recursive){:target="_blank"}  
