---
layout: post
title: leetcode - [198] House Robber
category: algorithm
tags: [algorithm]
excerpt: House Robber
---

## 题目描述  

> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.  

> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.  

假设有一个小偷要在一条街上作案，每间房间内都有一定的现金，但是不能偷相邻两间房间内的现金，不然会触发安全警报，请问小偷最多可以成功偷多少现金？  

举个例子：

``` java
Input: [2,1,1,2]
Output: 4
```

## Update at 2020_0604  

令`dp`与`nums`数组的大小一致：  

``` java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        // Corner case.
        if (len == 0) return 0;
        if (len == 1) return nums[0];

        // Initialization dp.
        int[] dp = new int[len];
        dp[0] = nums[0];
        // Think about nums = [2, 1]
        dp[1] = Math.max(dp[0], nums[1]);

        for (int i = 2; i < len; i++){
            // formula.
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[len - 1];
    }
}
```


## Update at 2020_0530  

原来是`DP[动态规划]`题目。  

来看下示意图：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_198_using_dp.png)  


首先，老规矩，明确`dp[i]`的意义是什么？  

> dp[i]表示当你抢到第i家时，能获取的最大利润。  

因为你不能抢相邻两家，所以可以得出如下公式：  

`dp[i] = Max(当前这家的利润 + dp[i-2], dp[i-1])`。  

再考虑下边界情况：  

`dp[0] = 0`，初始利润为零。  

`dp[1] = nums[0]`，为第一家的利润。  

实现如下：  


``` java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0) return 0;
        
        int[] dp = new int[len + 1];
        dp[1] = nums[0];

        for (int i = 2; i <= len; i++){
            int cur= nums[i - 1];
            dp[i] = Math.max(cur + dp[i - 2], dp[i - 1]);
        }
        return dp[len];
    }
}
```




## 解法1  

Thanks [@heroes3001](https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.){:target="_blank"}  

核心思想在于这个公式： 

`rob(i) = Math.max(rob(i - 2) + nums[i], rob(i - 1));`

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_198.png)  


``` java
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    int a = 0, b = 0;
    for (int n: nums){
        int cur = Math.max(a + n, b);
        a = b;
        b = cur;
    }
    return b;
}
```
