---
layout: post
title: leetcode - [21] Merge Two Sorted Lists
category: algorithm
tags: [algorithm]
excerpt: Merge Two Sorted Lists
---

## 题目描述  

> Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.  

合并两个有序的链表。  

举个例子：  

``` java
Input: 1->3, 2->4->5->6
Output: 1->2->3->4->5->6
```

## 解法1 - 迭代  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_21_iterative.png)  

这道题的关键在于需要借助`两个链表`，`curNode`用于寻找下一个节点，`dummyNode`用于保存已排序的节点。  

``` java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummyNode = new ListNode(0);
    ListNode curNode   = dummyNode;
    while (l1 != null && l2 != null){
        if (l1.val < l2.val){
            curNode.next = l1;
            l1 = l1.next;
        } else {
            curNode.next = l2;
            l2 = l2.next;
        }
        curNode = curNode.next;
    }
    
    if (l1 != null){
        curNode.next = l1;
    }
    
    if (l2 != null){
        curNode.next = l2;
    }
    return dummyNode.next;
}
```

## Update 2020_0502

仍然需要深刻思考一个问题，为什么要使用`curNode`？  

我的理解是：你需要一个链表来表示当前待拼接的节点，还需要一个链表来保存已拼接的节点！  

先来看个例子：  


``` java
public class ListNode {

    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
    }

    @Override
    public String toString() {
        return "ListNode{" +
                "val=" + val +
                ", next=" + next +
                '}';
    }
}

@Test
public void curNodeChange(){
    ListNode l1 = new ListNode(1);
    ListNode l2 = new ListNode(2);
    ListNode l3 = new ListNode(3);
    l1.next = l2;
    l2.next = l3;

    ListNode dummyNode = new ListNode(0);
    ListNode curNode   = dummyNode;

    curNode.next = l1;

    System.out.println(dummyNode);
    System.out.println(curNode);
}

// ListNode{val=0, next=ListNode{val=1, next=ListNode{val=2, next=ListNode{val=3, next=null}}}}
// ListNode{val=0, next=ListNode{val=1, next=ListNode{val=2, next=ListNode{val=3, next=null}}}}
```

虽然只改变了`curNode`的下一个节点，但是`dummyNode`链表也发生了改变。  

再来详细举个例子，给你两个有序的链表：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_21_example.png)  

`dummyNode`和`curNode`的初始值是这样的：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_21_dummyNode_init.png)  

正式开始：  

- 第一步  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_21_process_1.png)  

- 第二步  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_21_process_2.png)  

- 第三步  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_21_process_3.png)  

- 第四步  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_21_process_4.png)  

- 第五步  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_21_process_5.png)  

- 第六步  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_21_process_6.png)  


最后，取`dummyNode.next`！  

## `Reference`  
- [[解題] LeetCode - 21 Merge Two Sorted Lists](http://glj8989332.blogspot.com/2019/08/leetcode-21-merge-two-sorted-lists.html?m=1){:target="_blank"}  
