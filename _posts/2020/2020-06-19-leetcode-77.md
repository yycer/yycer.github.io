---
layout: post
title: leetcode - [77] Combinations
category: algorithm
tags: [algorithm]
excerpt: Combinations
---

## 问题描述  

> Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.  

计算`1...n`组合成`k`的组合数量。  

举个例子：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_77_demo.png)  


## 解法1  

先来看下示意图：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_77_key.png)  

首先，我们需要什么东西？  

我需要一个存储结果的嵌套列表`ans`，一个临时列表`child`，还有一个当前值`start`。  

注意，`start`初始值为`1`，因为`n`从`1`开始。  

然后，由于不能添加重复的集合，所以递归函数中的`start = i + 1`  

接着，考虑下递归函数的终止条件是什么？  

当子列表`child`中元素个数等于`k`，说明我们找到了一个答案。  

为了避免不必要的递归遍历，即`child.size() > k`的场景，后面的所有结果我们都不需要，所以直接快速返回。  


来看下实现：  


``` java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        
        List<List<Integer>> ans = new LinkedList<>();
        bt(n, k, 1, ans, new LinkedList<>());
        return ans;
    }
    
    private void bt(int n, int k, int start, List<List<Integer>> ans, LinkedList<Integer> child){

        if (child.size() > k){
            return;
        }
        
        if (child.size() == k){
            ans.add(new LinkedList<>(child));
        }
        
        for (int i = start; i <= n; i++){
            child.add(i);
            bt(n, k, i + 1, ans, child);
            child.removeLast();
        }
    }
}
```

`Enjoy it ! `