---
layout: post
title: leetcode - [69] Sqrt(x)
category: algorithm
tags: [algorithm]
excerpt: Sqrt(x)
---

## 题目描述  

> Implement int sqrt(int x).  

> Compute and return the square root of x, where x is guaranteed to be a non-negative integer.  

> Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.  

给一个非负整数，对其开方，并返回其整数部分。  

举个例子：  

``` java
Example 1:
Input: 4
Output: 2

Example 2:
Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since 
             the decimal part is truncated, 2 is returned.
```


## Update at 2020_0716  

拿这道题总结一下`Y总`的二分板子~  

先来看下示意图：  


![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_binary_serach_module_key.png)  


二分的实质在于根据某个性质，将区间一分为二。  

那么会有两种情况，第一种目标值在`左`边，也就是`红色`点，  

它代表的含义是指，满足该性质的点在左边，而右边没有，对应模板：  

``` java
int bsearch_left(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

注意有个`+1`喔，避免`向下取整`导致死循环。  


那么第二种情况就是满足性质的值在`右`边，也就是`蓝色`点，对于模板如下：  


``` java
int bsearch_right(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

再来看下这道题，由于它的去除小数部分，那么就是找左边的值，用左模板即可。  

分别来看下两种情况：  

- 左模板  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_69_2020_0716_left.png)  


- 右模板  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_69_2020_0716_right.png)  


``` java
class Solution {
    public int mySqrt(int x) {
        
        int l = 0, r = x;
        while (l < r){
            int mid = l + r + 1 >> 1;
            if (mid <= x / mid) l = mid;
            else r = mid - 1;
        }
        return l;
    }
}
```


## Update 2020_0519  

需要注意：`lo = 1`！  

来看下两种边界情况：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_69_lo_equals_1.png)  


## 解法1

我的想法是使用二分思想：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_69_common.png)  

实现如下：  

``` java
public int mySqrt(int x) {

    long lo = 1, hi = x;
    while (lo <= hi){
        long mid = lo + ((hi - lo) >> 1);
        long midSquare = mid * mid;
        if (midSquare == x){
            return (int) mid;
        } else if (midSquare < x){
            lo = mid + 1;
        } else {
            hi = mid - 1;
        }
    }
    return (int) hi;
}
```

来来来，思考一个很严肃的问题，为什么要用`start <= end`？用`start < end`不行么？  

不行！原因如下：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_69_while_equals.png)  

显然，我们想要的结果是`2`，但实际返回却是`3`！  

再来，为什么要用`lo = mid + 1;`？用`lo = mid;`不行么？  

不行！原因如下：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_69_lo.png)  

继续，为什么要用`hi = mid - 1;`？用`hi = mid;`不行么？  

不行！原因如下：  

![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_69_hi.png)  


最后，能不用`long`类型么？  


这个可以有~  

Thanks [@yavinci](https://leetcode.com/problems/sqrtx/discuss/25047/A-Binary-Search-Solution){:target="_blank"}  


![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_69_using_divide_and_int.png)  

实现如下：  


``` java
public int mySqrt(int x) {
    int lo = 1, hi = x;
    while (lo <= hi){
        int mid = lo + ((hi - lo) >> 1);
        if (x / mid == mid){
            return mid;
        } else if (x / mid < mid){
            hi = mid - 1;
        } else {
            lo = mid + 1;
        }
    }
    return hi;
}
```

`Enjoy it!`
